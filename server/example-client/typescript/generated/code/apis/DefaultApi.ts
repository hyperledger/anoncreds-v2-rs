/* tslint:disable */
/* eslint-disable */
/**
 * vcp_server
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AccumulatorAddRemoveRequest,
  AccumulatorAddRemoveResponse,
  AuthorityData,
  BlindSigningInfo,
  CreateAccumulatorResponse,
  CreateBlindSigningInfoRequest,
  CreateProofRequest,
  CreateSignerDataRequest,
  SignRequest,
  SignWithBlindedAttributesRequest,
  SignerData,
  UnblindBlindedSignatureRequest,
  UpdateAccumulatorWitnessRequest,
  VerifyDecryptionRequest,
  VerifyProofRequest,
  Warning,
  WarningsAndDataForVerifier,
  WarningsAndDecryptResponses,
} from '../models/index';
import {
    AccumulatorAddRemoveRequestFromJSON,
    AccumulatorAddRemoveRequestToJSON,
    AccumulatorAddRemoveResponseFromJSON,
    AccumulatorAddRemoveResponseToJSON,
    AuthorityDataFromJSON,
    AuthorityDataToJSON,
    BlindSigningInfoFromJSON,
    BlindSigningInfoToJSON,
    CreateAccumulatorResponseFromJSON,
    CreateAccumulatorResponseToJSON,
    CreateBlindSigningInfoRequestFromJSON,
    CreateBlindSigningInfoRequestToJSON,
    CreateProofRequestFromJSON,
    CreateProofRequestToJSON,
    CreateSignerDataRequestFromJSON,
    CreateSignerDataRequestToJSON,
    SignRequestFromJSON,
    SignRequestToJSON,
    SignWithBlindedAttributesRequestFromJSON,
    SignWithBlindedAttributesRequestToJSON,
    SignerDataFromJSON,
    SignerDataToJSON,
    UnblindBlindedSignatureRequestFromJSON,
    UnblindBlindedSignatureRequestToJSON,
    UpdateAccumulatorWitnessRequestFromJSON,
    UpdateAccumulatorWitnessRequestToJSON,
    VerifyDecryptionRequestFromJSON,
    VerifyDecryptionRequestToJSON,
    VerifyProofRequestFromJSON,
    VerifyProofRequestToJSON,
    WarningFromJSON,
    WarningToJSON,
    WarningsAndDataForVerifierFromJSON,
    WarningsAndDataForVerifierToJSON,
    WarningsAndDecryptResponsesFromJSON,
    WarningsAndDecryptResponsesToJSON,
} from '../models/index';

export interface AccumulatorAddRemoveOperationRequest {
    zkpLib: string;
    accumulatorAddRemoveRequest: AccumulatorAddRemoveRequest;
}

export interface CreateAccumulatorDataRequest {
    zkpLib?: string | null;
    rngSeed?: number | null;
}

export interface CreateAccumulatorElementRequest {
    zkpLib: string;
    body: string;
}

export interface CreateAuthorityDataRequest {
    zkpLib?: string | null;
    rngSeed?: number | null;
}

export interface CreateBlindSigningInfoOperationRequest {
    createBlindSigningInfoRequest: CreateBlindSigningInfoRequest;
    zkpLib?: string | null;
    rngSeed?: number | null;
}

export interface CreateMembershipProvingKeyRequest {
    zkpLib?: string | null;
    rngSeed?: number | null;
}

export interface CreateProofOperationRequest {
    zkpLib: string;
    createProofRequest: CreateProofRequest;
}

export interface CreateRangeProofProvingKeyRequest {
    zkpLib?: string | null;
    rngSeed?: number | null;
}

export interface CreateSignerDataOperationRequest {
    createSignerDataRequest: CreateSignerDataRequest;
    zkpLib?: string | null;
    rngSeed?: number | null;
}

export interface GetRangeProofMaxValueRequest {
    zkpLib: string;
}

export interface SignOperationRequest {
    signRequest: SignRequest;
    zkpLib?: string | null;
    rngSeed?: number | null;
}

export interface SignWithBlindedAttributesOperationRequest {
    signWithBlindedAttributesRequest: SignWithBlindedAttributesRequest;
    zkpLib?: string | null;
    rngSeed?: number | null;
}

export interface UnblindBlindedSignatureOperationRequest {
    unblindBlindedSignatureRequest: UnblindBlindedSignatureRequest;
    zkpLib?: string | null;
    rngSeed?: number | null;
}

export interface UpdateAccumulatorWitnessOperationRequest {
    zkpLib: string;
    updateAccumulatorWitnessRequest: UpdateAccumulatorWitnessRequest;
}

export interface VerifyDecryptionOperationRequest {
    zkpLib: string;
    verifyDecryptionRequest: VerifyDecryptionRequest;
}

export interface VerifyProofOperationRequest {
    zkpLib: string;
    verifyProofRequest: VerifyProofRequest;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Returns AccumulatorAddRemoveResponse.
     * Add and/or remove elements from an accumulator.
     */
    async accumulatorAddRemoveRaw(requestParameters: AccumulatorAddRemoveOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccumulatorAddRemoveResponse>> {
        if (requestParameters['zkpLib'] == null) {
            throw new runtime.RequiredError(
                'zkpLib',
                'Required parameter "zkpLib" was null or undefined when calling accumulatorAddRemove().'
            );
        }

        if (requestParameters['accumulatorAddRemoveRequest'] == null) {
            throw new runtime.RequiredError(
                'accumulatorAddRemoveRequest',
                'Required parameter "accumulatorAddRemoveRequest" was null or undefined when calling accumulatorAddRemove().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['zkpLib'] != null) {
            queryParameters['zkpLib'] = requestParameters['zkpLib'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/vcp/accumulatorAddRemove`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AccumulatorAddRemoveRequestToJSON(requestParameters['accumulatorAddRemoveRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccumulatorAddRemoveResponseFromJSON(jsonValue));
    }

    /**
     * Returns AccumulatorAddRemoveResponse.
     * Add and/or remove elements from an accumulator.
     */
    async accumulatorAddRemove(requestParameters: AccumulatorAddRemoveOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccumulatorAddRemoveResponse> {
        const response = await this.accumulatorAddRemoveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns CreateAccumulatorResponse.
     * Create an accumulator and its associated secret/public data.
     */
    async createAccumulatorDataRaw(requestParameters: CreateAccumulatorDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateAccumulatorResponse>> {
        const queryParameters: any = {};

        if (requestParameters['zkpLib'] != null) {
            queryParameters['zkpLib'] = requestParameters['zkpLib'];
        }

        if (requestParameters['rngSeed'] != null) {
            queryParameters['rngSeed'] = requestParameters['rngSeed'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/vcp/createAccumulatorData`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateAccumulatorResponseFromJSON(jsonValue));
    }

    /**
     * Returns CreateAccumulatorResponse.
     * Create an accumulator and its associated secret/public data.
     */
    async createAccumulatorData(requestParameters: CreateAccumulatorDataRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateAccumulatorResponse> {
        const response = await this.createAccumulatorDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns AccumulatorElement.
     * Create an accumulator element from the given text.
     */
    async createAccumulatorElementRaw(requestParameters: CreateAccumulatorElementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['zkpLib'] == null) {
            throw new runtime.RequiredError(
                'zkpLib',
                'Required parameter "zkpLib" was null or undefined when calling createAccumulatorElement().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createAccumulatorElement().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['zkpLib'] != null) {
            queryParameters['zkpLib'] = requestParameters['zkpLib'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/vcp/createAccumulatorElement`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Returns AccumulatorElement.
     * Create an accumulator element from the given text.
     */
    async createAccumulatorElement(requestParameters: CreateAccumulatorElementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.createAccumulatorElementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns AuthorityData.
     * Create authority data.  Used in verifiable encryption.
     */
    async createAuthorityDataRaw(requestParameters: CreateAuthorityDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthorityData>> {
        const queryParameters: any = {};

        if (requestParameters['zkpLib'] != null) {
            queryParameters['zkpLib'] = requestParameters['zkpLib'];
        }

        if (requestParameters['rngSeed'] != null) {
            queryParameters['rngSeed'] = requestParameters['rngSeed'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/vcp/createAuthorityData`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthorityDataFromJSON(jsonValue));
    }

    /**
     * Returns AuthorityData.
     * Create authority data.  Used in verifiable encryption.
     */
    async createAuthorityData(requestParameters: CreateAuthorityDataRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthorityData> {
        const response = await this.createAuthorityDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns BlindSigningInfo
     * Create BlindSigningInfo
     */
    async createBlindSigningInfoRaw(requestParameters: CreateBlindSigningInfoOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlindSigningInfo>> {
        if (requestParameters['createBlindSigningInfoRequest'] == null) {
            throw new runtime.RequiredError(
                'createBlindSigningInfoRequest',
                'Required parameter "createBlindSigningInfoRequest" was null or undefined when calling createBlindSigningInfo().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['zkpLib'] != null) {
            queryParameters['zkpLib'] = requestParameters['zkpLib'];
        }

        if (requestParameters['rngSeed'] != null) {
            queryParameters['rngSeed'] = requestParameters['rngSeed'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/vcp/createBlindSigningInfo`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateBlindSigningInfoRequestToJSON(requestParameters['createBlindSigningInfoRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlindSigningInfoFromJSON(jsonValue));
    }

    /**
     * Returns BlindSigningInfo
     * Create BlindSigningInfo
     */
    async createBlindSigningInfo(requestParameters: CreateBlindSigningInfoOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlindSigningInfo> {
        const response = await this.createBlindSigningInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns MembershipProvingKey.
     * Create accumulator membership proving key.
     */
    async createMembershipProvingKeyRaw(requestParameters: CreateMembershipProvingKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        if (requestParameters['zkpLib'] != null) {
            queryParameters['zkpLib'] = requestParameters['zkpLib'];
        }

        if (requestParameters['rngSeed'] != null) {
            queryParameters['rngSeed'] = requestParameters['rngSeed'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/vcp/createMembershipProvingKey`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Returns MembershipProvingKey.
     * Create accumulator membership proving key.
     */
    async createMembershipProvingKey(requestParameters: CreateMembershipProvingKeyRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.createMembershipProvingKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns WarningsAndDataForVerifier.
     * Create a proof with respect to proof requirements from a Verifier.
     */
    async createProofRaw(requestParameters: CreateProofOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WarningsAndDataForVerifier>> {
        if (requestParameters['zkpLib'] == null) {
            throw new runtime.RequiredError(
                'zkpLib',
                'Required parameter "zkpLib" was null or undefined when calling createProof().'
            );
        }

        if (requestParameters['createProofRequest'] == null) {
            throw new runtime.RequiredError(
                'createProofRequest',
                'Required parameter "createProofRequest" was null or undefined when calling createProof().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['zkpLib'] != null) {
            queryParameters['zkpLib'] = requestParameters['zkpLib'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/vcp/createProof`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateProofRequestToJSON(requestParameters['createProofRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WarningsAndDataForVerifierFromJSON(jsonValue));
    }

    /**
     * Returns WarningsAndDataForVerifier.
     * Create a proof with respect to proof requirements from a Verifier.
     */
    async createProof(requestParameters: CreateProofOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WarningsAndDataForVerifier> {
        const response = await this.createProofRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns RangeProofProvingKey.
     * Create range proof proving key.
     */
    async createRangeProofProvingKeyRaw(requestParameters: CreateRangeProofProvingKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        if (requestParameters['zkpLib'] != null) {
            queryParameters['zkpLib'] = requestParameters['zkpLib'];
        }

        if (requestParameters['rngSeed'] != null) {
            queryParameters['rngSeed'] = requestParameters['rngSeed'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/vcp/createRangeProofProvingKey`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Returns RangeProofProvingKey.
     * Create range proof proving key.
     */
    async createRangeProofProvingKey(requestParameters: CreateRangeProofProvingKeyRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.createRangeProofProvingKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns SignerData.
     * Create the secret and public data used to sign and verify credentials.
     */
    async createSignerDataRaw(requestParameters: CreateSignerDataOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SignerData>> {
        if (requestParameters['createSignerDataRequest'] == null) {
            throw new runtime.RequiredError(
                'createSignerDataRequest',
                'Required parameter "createSignerDataRequest" was null or undefined when calling createSignerData().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['zkpLib'] != null) {
            queryParameters['zkpLib'] = requestParameters['zkpLib'];
        }

        if (requestParameters['rngSeed'] != null) {
            queryParameters['rngSeed'] = requestParameters['rngSeed'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/vcp/createSignerData`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateSignerDataRequestToJSON(requestParameters['createSignerDataRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SignerDataFromJSON(jsonValue));
    }

    /**
     * Returns SignerData.
     * Create the secret and public data used to sign and verify credentials.
     */
    async createSignerData(requestParameters: CreateSignerDataOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SignerData> {
        const response = await this.createSignerDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the maximum value.
     * Get the maximum value supported in range proofs for the specific zkpLib.
     */
    async getRangeProofMaxValueRaw(requestParameters: GetRangeProofMaxValueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<number>> {
        if (requestParameters['zkpLib'] == null) {
            throw new runtime.RequiredError(
                'zkpLib',
                'Required parameter "zkpLib" was null or undefined when calling getRangeProofMaxValue().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['zkpLib'] != null) {
            queryParameters['zkpLib'] = requestParameters['zkpLib'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/vcp/getRangeProofMaxValue`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<number>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Returns the maximum value.
     * Get the maximum value supported in range proofs for the specific zkpLib.
     */
    async getRangeProofMaxValue(requestParameters: GetRangeProofMaxValueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<number> {
        const response = await this.getRangeProofMaxValueRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns Signature.
     * Create a signature from the given values and SignerData.
     */
    async signRaw(requestParameters: SignOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['signRequest'] == null) {
            throw new runtime.RequiredError(
                'signRequest',
                'Required parameter "signRequest" was null or undefined when calling sign().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['zkpLib'] != null) {
            queryParameters['zkpLib'] = requestParameters['zkpLib'];
        }

        if (requestParameters['rngSeed'] != null) {
            queryParameters['rngSeed'] = requestParameters['rngSeed'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/vcp/sign`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SignRequestToJSON(requestParameters['signRequest']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Returns Signature.
     * Create a signature from the given values and SignerData.
     */
    async sign(requestParameters: SignOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.signRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a BlindSignature.
     * Create a BlindSignature from the given non-blinded values, blinding info and SignerData.
     */
    async signWithBlindedAttributesRaw(requestParameters: SignWithBlindedAttributesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['signWithBlindedAttributesRequest'] == null) {
            throw new runtime.RequiredError(
                'signWithBlindedAttributesRequest',
                'Required parameter "signWithBlindedAttributesRequest" was null or undefined when calling signWithBlindedAttributes().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['zkpLib'] != null) {
            queryParameters['zkpLib'] = requestParameters['zkpLib'];
        }

        if (requestParameters['rngSeed'] != null) {
            queryParameters['rngSeed'] = requestParameters['rngSeed'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/vcp/signWithBlindedAttributes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SignWithBlindedAttributesRequestToJSON(requestParameters['signWithBlindedAttributesRequest']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Returns a BlindSignature.
     * Create a BlindSignature from the given non-blinded values, blinding info and SignerData.
     */
    async signWithBlindedAttributes(requestParameters: SignWithBlindedAttributesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.signWithBlindedAttributesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns Signature.
     * Unblinded a blinded signature.
     */
    async unblindBlindedSignatureRaw(requestParameters: UnblindBlindedSignatureOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['unblindBlindedSignatureRequest'] == null) {
            throw new runtime.RequiredError(
                'unblindBlindedSignatureRequest',
                'Required parameter "unblindBlindedSignatureRequest" was null or undefined when calling unblindBlindedSignature().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['zkpLib'] != null) {
            queryParameters['zkpLib'] = requestParameters['zkpLib'];
        }

        if (requestParameters['rngSeed'] != null) {
            queryParameters['rngSeed'] = requestParameters['rngSeed'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/vcp/unblindBlindedSignature`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UnblindBlindedSignatureRequestToJSON(requestParameters['unblindBlindedSignatureRequest']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Returns Signature.
     * Unblinded a blinded signature.
     */
    async unblindBlindedSignature(requestParameters: UnblindBlindedSignatureOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.unblindBlindedSignatureRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns AccumulatorMembershipWitness.
     * Update an accumulator witness.
     */
    async updateAccumulatorWitnessRaw(requestParameters: UpdateAccumulatorWitnessOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['zkpLib'] == null) {
            throw new runtime.RequiredError(
                'zkpLib',
                'Required parameter "zkpLib" was null or undefined when calling updateAccumulatorWitness().'
            );
        }

        if (requestParameters['updateAccumulatorWitnessRequest'] == null) {
            throw new runtime.RequiredError(
                'updateAccumulatorWitnessRequest',
                'Required parameter "updateAccumulatorWitnessRequest" was null or undefined when calling updateAccumulatorWitness().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['zkpLib'] != null) {
            queryParameters['zkpLib'] = requestParameters['zkpLib'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/vcp/updateAccumulatorWitness`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateAccumulatorWitnessRequestToJSON(requestParameters['updateAccumulatorWitnessRequest']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Returns AccumulatorMembershipWitness.
     * Update an accumulator witness.
     */
    async updateAccumulatorWitness(requestParameters: UpdateAccumulatorWitnessOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.updateAccumulatorWitnessRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns list of Warnings.
     * Verify a decryption.
     */
    async verifyDecryptionRaw(requestParameters: VerifyDecryptionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Warning>>> {
        if (requestParameters['zkpLib'] == null) {
            throw new runtime.RequiredError(
                'zkpLib',
                'Required parameter "zkpLib" was null or undefined when calling verifyDecryption().'
            );
        }

        if (requestParameters['verifyDecryptionRequest'] == null) {
            throw new runtime.RequiredError(
                'verifyDecryptionRequest',
                'Required parameter "verifyDecryptionRequest" was null or undefined when calling verifyDecryption().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['zkpLib'] != null) {
            queryParameters['zkpLib'] = requestParameters['zkpLib'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/vcp/verifyDecryption`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: VerifyDecryptionRequestToJSON(requestParameters['verifyDecryptionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WarningFromJSON));
    }

    /**
     * Returns list of Warnings.
     * Verify a decryption.
     */
    async verifyDecryption(requestParameters: VerifyDecryptionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Warning>> {
        const response = await this.verifyDecryptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns WarningsAndDecryptResponses.
     * Verify a proof with respect to proof requirments.
     */
    async verifyProofRaw(requestParameters: VerifyProofOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WarningsAndDecryptResponses>> {
        if (requestParameters['zkpLib'] == null) {
            throw new runtime.RequiredError(
                'zkpLib',
                'Required parameter "zkpLib" was null or undefined when calling verifyProof().'
            );
        }

        if (requestParameters['verifyProofRequest'] == null) {
            throw new runtime.RequiredError(
                'verifyProofRequest',
                'Required parameter "verifyProofRequest" was null or undefined when calling verifyProof().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['zkpLib'] != null) {
            queryParameters['zkpLib'] = requestParameters['zkpLib'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/vcp/verifyProof`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: VerifyProofRequestToJSON(requestParameters['verifyProofRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WarningsAndDecryptResponsesFromJSON(jsonValue));
    }

    /**
     * Returns WarningsAndDecryptResponses.
     * Verify a proof with respect to proof requirments.
     */
    async verifyProof(requestParameters: VerifyProofOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WarningsAndDecryptResponses> {
        const response = await this.verifyProofRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
